# discovery/pentesttools.py
from Plugins.infoGather.subdomain.theHarvester.runTheHarvester.discovery.constants import *
from Plugins.infoGather.subdomain.theHarvester.runTheHarvester.lib.core import *
import json
import asyncio
from timeit import default_timer as timer


class SearchPentestTools:

    def __init__(self, word):
        self.word = word
        self.key = Core.pentest_tools_key()
        if self.key is None:
            raise MissingKey(True)
        self.total_results = []
        self.api = f'https://pentest-tools.com/api?key={self.key}'
        self.proxy = False

    async def poll(self, scan_id):
        start = timer()
        clock = 300
        while True:
            current_time = timer()
            if current_time - start >= clock:
                status = input(f'Pentesttools scan has reached {clock // 60 } minute mark would you like to stop scan: '
                               f'y/n')
                clock *= 2
                if status == 'y':
                    return self.total_results

            await asyncio.sleep(3)
            scan_status_data = {
                "op": "get_scan_status",
                "scan_id": scan_id
            }
            responses = await AsyncFetcher.post_fetch(url=self.api,
                                                      data=json.dumps(scan_status_data),
                                                      proxy=self.proxy)
            if not responses:
                break
            res_json = json.loads(responses.strip())
            if res_json["op_status"] == "success":
                if res_json["scan_status"] != "waiting" and res_json["scan_status"] != "running":
                    getoutput_data = {
                        "op": "get_output",
                        "scan_id": scan_id,
                        "output_format": 'json'
                    }
                    responses = await AsyncFetcher.post_fetch(url=self.api,
                                                              data=json.dumps(getoutput_data),
                                                              proxy=self.proxy)
                    if responses:
                        res_json = json.loads(responses.strip())
                        self.total_results = await self.parse_json(res_json)
                    break
            else:
                print(f"Operation get_scan_status failed because: {res_json['error']}. {res_json['details']}")
                break

    @staticmethod
    async def parse_json(json_results):
        status = json_results.get('op_status')
        if status == 'success':
            scan_tests = json_results.get('scan_output', {}).get('scan_tests', [])
            if scan_tests:
                output_data = scan_tests[0].get('output_data', [])
                host_to_ip = [f'{subdomain[0]}:{subdomain[1]}' for subdomain in output_data if len(subdomain) > 0]
                return host_to_ip
        return []

    async def get_hostnames(self) -> list:
        return self.total_results

    async def do_search(self):
        subdomain_payload = {
            'op': 'start_scan',
            'tool_id': 20,
            'tool_params': {
                'target': f'{self.word}'},
            "scan_type": "quick"
        }
        responses = await AsyncFetcher.post_fetch(url=self.api,
                                                  data=json.dumps(subdomain_payload),
                                                  proxy=self.proxy)
        if responses:
            res_json = json.loads(responses.strip())
            if res_json["op_status"] == "success":
                scan_id = res_json.get('scan_id')
                if scan_id:
                    await self.poll(scan_id)

    async def process(self, proxy=False):
        print('Pentesttools may take over 10 minutes to run!')
        self.proxy = proxy
        await self.do_search()